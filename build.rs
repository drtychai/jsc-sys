extern crate bindgen;
use bindgen::{builder, Bindings};

use std::path::PathBuf;
use std::process::{Command, Stdio};
use std::result::Result;
use std::{env, fs};

/// Returns an std::path::PathBuf triplet representing the enironment variables:
///
///     CARGO_MANIFEST_DIR                             : Directory containing our Cargo.toml
///     OUT_DIR                                        : Build output directroy
///     OUT_DOR/DerivedSources/ForwardingHeaders       : JSC definitions used to generate bindings
///
/// If an environment variable is not set, the current workding directory is used.
fn get_paths_from_env() -> (PathBuf, PathBuf, PathBuf) {
    let cargo_manifest_dir = if let Some(val) = env::var_os("CARGO_MANIFEST_DIR") {
        PathBuf::from(val)
    } else {
        PathBuf::from(env::current_dir().unwrap())
    };

    let (build_dir, jsc_shim_h) = if let Some(val) = env::var_os("OUT_DIR") {
        // Set build directory to our anticipated path
        // This path is not reachable until after makefile.cargo execution
        let rs_build_dir = PathBuf::from(val).join("build");
        (
            rs_build_dir.clone(),
            rs_build_dir.join("DerivedSources/ForwardingHeaders"),
        )
    } else {
        // Set build directory and target header to WebKit defaults
        (
            PathBuf::from(env::current_dir().unwrap()).join("Webkit/WebKitBuild"),
            PathBuf::from(env::current_dir().unwrap())
                .join("Webkit/WebKitBuild/Debug")
                .join("DerivedSources/ForwardingHeaders")
                .join("JavaScriptCore/JavaScript.h"),
        )
    };
    fs::create_dir_all(&build_dir).expect("could not create build dir");
    println!("cargo:outdir={}", build_dir.display());
    (cargo_manifest_dir, build_dir, jsc_shim_h)
}

/// Returns the FFI bindings generated by the (toolchain-specific) builder
fn generate_bindings(target_headers: &PathBuf) -> Result<Bindings, ()> {
    #[cfg(all(target_os = "macos", target_arch = "x86_64"))]
    let target_toolchain = "--target=x86_64-apple-darwin";

    #[cfg(all(target_os = "linux", target_arch = "x86_64"))]
    let target_toolchain = "--target=x86_64-unknown-linux-musl";

    builder()
        .header(
            target_headers
                .clone()
                .join("JavaScriptCore/JavaScript.h")
                .to_str()
                .unwrap(),
        )
        .clang_arg(target_toolchain)
        // Tell cargo to invalidate the built crate whenever any of the included header files changed.
        .parse_callbacks(Box::new(bindgen::CargoCallbacks))
        .generate()
}

fn main() {
    let (cargo_manifest_dir, build_dir, jsc_shim_h) = get_paths_from_env();

    // Initial build as JSCOnly;static;debug
    let result = Command::new("make")
        .args(&["-R", "-f"])
        .arg(cargo_manifest_dir.join("makefile.cargo"))
        .current_dir(&build_dir)
        .stdout(Stdio::inherit())
        .stderr(Stdio::inherit())
        .status()
        .unwrap();
    assert!(result.success());

    if (cfg!(target_os = "macos") || cfg!(target_os = "linux")) && cfg!(target_arch = "x86_64") {
        let bindings =
            generate_bindings(&jsc_shim_h).expect("Builder could not generate bindings D:");

        bindings
            .write_to_file(build_dir.join("bindings.rs"))
            .expect("Couldn't write bindings!");
    } else {
        let supported_targets = ["x86_64-unknown-linux-musl", "x86_64-apple-darwin"];
        panic!(
            "Current OS and/or Arch not supported... here are the supported builds: {:?}",
            supported_targets
        );
    }
}
