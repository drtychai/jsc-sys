extern crate bindgen;
use std::{env, fs};
use std::path::PathBuf;
use std::process::{Command, Stdio};
use std::result::Result;

use bindgen::{builder, Bindings};

/// Returns the FFI bindings generated by the (toolchain-specific) builder
fn generate_bindings(target_header: &str) -> Result<Bindings, ()> {
    #[cfg(all(target_os = "macos", target_arch = "x86_64"))]
    let target_toolchain = "--target=x86_64-apple-darwin";

    #[cfg(all(target_os = "linux", target_arch = "x86_64"))]
    let target_toolchain = "--target=x86_64-unknown-linux-musl";

    builder()
        .header(target_header)
        .clang_arg(target_toolchain)
        // Tell cargo to invalidate the built crate whenever any of the included header files changed.
        .parse_callbacks(Box::new(bindgen::CargoCallbacks))
        .generate()
}


/// Returns an std::path::PathBuf triplet representing the enironment variables:
///
///     CARGO_MANIFEST_DIR                             : Directory container our Cargo.toml
///     CARGO_MANIFEST_DIR/jsc-defs_*/JavaScriptCore.h : JSC Shim provided in the crate
///     OUT_DIR                                        : Build output directroy
///
/// If an environment variable is not set, the current workding directory is used.
fn get_paths_from_env() -> (PathBuf, PathBuf, PathBuf) {
    let (cargo_manifest_dir, shim) = if let Some(val) = env::var_os("CARGO_MANIFEST_DIR") {
        let cwd = PathBuf::from(val);
        (
            cwd.clone(),
            cwd.join("jsc-defs_cc153d7799a75e501fa5ca3f6a005744395cc32b")
                .join("JavaScriptCore.h"),
        )
    } else {
        let cwd = PathBuf::from(env::current_dir().unwrap());
        (
            cwd.clone(),
            cwd.join("jsc-defs_cc153d7799a75e501fa5ca3f6a005744395cc32b")
                .join("JavaScriptCore.h"),
        )
    };

    let build_dir = if let Some(val) = env::var_os("OUT_DIR") {
        PathBuf::from(val).join("build")
    } else {
        PathBuf::from(env::current_dir().unwrap()).join("Webkit/WebKitBuild")
    };
    fs::create_dir_all(&build_dir).expect("could not create build dir");
    println!("cargo:outdir={}", build_dir.display());
    (cargo_manifest_dir, build_dir, shim)
}

fn main() {
    let (cargo_manifest_dir, build_dir, lib_shim) = get_paths_from_env();

    // Initial build as JSCOnly;static;debug
    let result = Command::new("make")
        .args(&["-R", "-f"])
        .arg(cargo_manifest_dir.join("makefile.cargo"))
        .current_dir(&build_dir)
        .stdout(Stdio::inherit())
        .stderr(Stdio::inherit())
        .status()
        .unwrap();
    assert!(result.success());

    if cfg!(target_os = "macos") || cfg!(target_os = "linux") {
        let bindings = generate_bindings(&lib_shim.display().to_string())
            .expect("Builder could not generate bindings D:");

        bindings
            .write_to_file(build_dir.join("bindings.rs"))
            .expect("Couldn't write bindings!");
    } else {
        let supported_targets = [
            "x86_64-unknown-linux-gnu",
            "x86_64-unknown-linux-musl",
            "x86_64-apple-darwin",
        ];
        panic!(
            "Current OS and/or Arch not supported... here are the supported builds: {:?}",
            supported_targets
        );
    }
}
